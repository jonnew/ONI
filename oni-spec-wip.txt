---
title: |
    Open Neuro Interface Specification \
    Version 1.0
authors: Jonathan P. Newman, Wilson Lab, MIT. Aarón Cuevas López
institution:
date: \today{}
geometry: margin=2cm
header-includes:
    - \usepackage{setspace}
    - \usepackage{lineno}
    - \linenumbers
colorlinks: true
toc: true
toc-depth: 2
secnumdepth: 2
abstract: |
    This document specifies requirements for implementing an Open Neuro
    Interface (ONI) acquisition system in hardware and software. This
    specification entails two basic elements: (1) Communication protocols
    between acquisition firmware and host software and (2) an application
    programming interface (API) for utilizing this communication protocol. This
    document is incomplete and we gratefully welcome criticisms and amendments.
---

\newpage
# Intentions and capabilities
- Potential for low latency round trip times (sub millisecond)
- Potential for high-bandwidth, bidirectional communication (> 1000 neural data
  channels)
- Acquisition and control of arbitrary of hardware components using a single
  communication medium
    - Support generic mixes of hardware elements from multiple, asynchronous
      pieces of hardware
    - Generic hardware configuration
    - Generic data input streams
    - Generic data output streams
- Support multiple acquisition systems on one computer
- Cross platform
- Aimed at the creation of firmware, APIs, language bindings and
  application-specific libraries

\newpage
# ONI system description and definitions {#ONI-description}
## Hierarchy elements {#ONI-hierarchy}
Any ONI-compliant system is comprised, structurally, of 3 hierarchic elements:
- **Device**: Any element that produces or consumes data. Those are the endpoints 
for most communication operations and often are the hardware interfacing with the 
physical environment.
- **Hub**: A collection of devices sharing a common clock. All data acquired by 
devices in the same hub are timestamped by this clock.
- **Controller**: The hardware with the physical interface to the computer.
All hubs are connected to the controller and data from their devices packed and 
transmitted to the host PC. It has a global clock which adds a second, common
timestamp to all data.

An ONI system, thus, must have a single controller and one or more hubs and devices. Hubs can be
independent hardware pieces, communicating to the controller, or share the same hardware. 
(e.g.: An FPGA can run the controller logic while, at the same time, including a
hub with local devices and connecting to external hubs through a digital link). Different
clock domains, even if they lie in the same hardware piece, must conform independent hubs.

## Communication channels {#ONI-channels}
The standard define two types of communication channels that will be used across the system:
- **Stream**: A unidirectional, asynchronous, channel of continuous data. The only signaling they expose
 is to indicate if they are ready to send/receive data.
Two directions are defined:
    - **Read**: Streams transmitting data from a device, or to the computer.
    - **Write**: Streams transmitting data to a device, or from the computer.
- **Registers**: A synchronous addressed interface. Each address contains a 32-bit value.
Individual addresses can be Read-only, Write-only or Read-Write. Signaling
exists to indicate a successful or failed completion of a register access operation.
An access to an non-existent address or a non-allowed operation will return an error. 

## Device map {#ONI-devmap}

The whole collection of available devices is referred as a device map. The controller
creates this aggregate and sends it to the computer.

Every device in the device map has a unique 32bit address of the format 
`Reserved(16bit).Hub_Index(8bit).Device_Index(8bit)` where *Reserved* must be all zeros,
 *Hub_Index* indicates a unique indexing of each hub within the controller, and
 *Device_Index* the unique index of each device within its Hub. Device index ranges
 from 0 to 0xFD, with 0xFE being reserved a 0xFF indicating an invalid device.

 \newpage
 # Devices {#devs}

 Devices are the endpoint of most ONI transactions. They can represent a physical element
 interfacing with the environment (e.g. an integrated circuit), something programmed within the
firmware to emulate this (e.g. an electrical stimulation sub-circuit made to
behave like a Master-8) or a purely internal data source (e.g.: to generate system  status reports).

 A device exposes the following interfaces:
 - A MANDATORY register interface
 - An OPTIONAL read stream
 - An OPTIONAL write streams

 Communication over the streams follows a specific *sample format*, while the register
 interface must comply with some specific rules. These will be described in detail in
 following sections. Device developers are encouraged to write _ONI Device Datasheets_ describing
 the register map, stream data types and general behavior of the device.

 Different types of devices have an associated identifier, *DeviceID* from now. This
 identifies not only the type of data produced or consumed, but also a particular 
 implementation. 

 *DeviceID*s in the range 0-100000 are reserved for elements implemented by Open Ephys,
 while any ID beyond that range can be freely used by third parties.

 A device must expose to the controller a descriptor, which will be read by the controller when it
 resets and incorporated into the device map. The descriptor must contain the following information:

 ```
 uint32    DeviceID
 uint32    Implementation_version
 uint32    Read_Sample_Size
 uint32    Write_Sample_Size
 ```

 DeviceID is as described before. Implementation_Version helps distinguish between revisions
 of a singular device. This might address minor issues. Any change that warrants a modification
 on the interface or data format must be implemented into a new *DeviceID*. Both sample sizes
 represent the length in bytes that of the sample packets traversing the Read or Write streams.
 If a device lacks one of such streams, it associated size must be 0.

 ## Device sample format {#dev-sample}

Data interchanged over the input or output streams is transmitted in unit packets, or _samples_.
A sample transmitted over the read stream must follow the following format:
```
uint64    Hub_Timestamp
var       Payload
```
Where *Hub_Timestamp* is a common counter for all devices in a hub, indicating the time of sample capture.
Payload represents the device-specific data, and must be of *Read_Sample_Size* - 4, thus the whole sample
packet fits into the sample size specified in the map.

Samples transmitted to the device over the write stream do not require a timestamp, so they are composed
by only a device-specific Payload of *Write_Sample_Size* bytes.

## Device registers {#dev-register}

### Register type

Addressed access to device registers can be separated into two types:
- _Raw registers_: Those that correspond 1:1 to the physical register space of an electrical component. 
 (e.g.: The register map in the manufacturer datasheet of a sensor IC)
 - _Managed registers_: Those designed to interface exclusively with an ONI system, usually implemented in firmware
and described in the _ONI Device Datasheet_

While raw registers provide a direct window to the underlying hardware, managed registers vary from properties unique
to the ONI interface to a way to hide hardware complexities, with the firmware managing low-level raw access to the hardware,
offering a simpler interface to the user applications.

### Register access and update

Registers, independently of their type, can be defined as Read-Write, Read-Only or Write-Only. All registers must have a 
valid value at power-on. Whenever the device receives a reset request generated by the controller, registers might either be
reset to their power-on value or keep their current value. This can be defined independently for each register.

All register writes must be immediate (i.e.: for a Read-Write register, reading a register after being written must reflect the new value).
However, the _effects_ of a register might not be in effect until the next reset. An example of these registers are those which
operate on the device descriptor. The descriptor must be static during runtime, but registers affecting it might take action
after a reset, providing an updates descriptor to the controller.

It is recommended for device developers to include register access, type and behavior in their _ONI Device Datasheet_.

### Register map

A device can optionally implement raw registers and must implement at least one managed register, `ENABLE`, a Read-Write register that takes
effect after reset. When `ENABLE` is disabled, the device must not produce any data through the data stream.

The location of the managed registers depends on the existence of raw registers. If the device implements raw registers, those are mapped to
addresses 0x0000 to 0x7FFF, corresponding to the same address map of the underlying hardware, and managed registers start from 0x80000.
If no raw registers are present, managed registers start from 0x0000 instead. 

The `ENABLE` register must be the first of the managed registers, at 0x0000 if no raw registers are present, 0x8000 if raw
 registers are implemented.

# Hubs {#hubs}

Hubs are collections of devices sharing a common acquisition clock. They can be independent hardware pieces connected to the controller
 (e.g.: a headstage for neural acquisition) or a logical partition of existing hardware (e.g.: A collection of devices implemented 
 in the same firmware as the controller). Independent hubs are referred as remote hubs, while the latter kind are local hubs. 

Any ONI-compliant system must implement at least one local hub, located at index 0, and can implement up to 253 additional hubs, 
local or remote. All devices representing the controller, reporting errors or similar status messages must be implemented in local hub 0.

A hub has a high-resolution timer that is passed to all its devices, which include it into their data frames as the *Hub_Timestamp*.

Data from all the devices of a hub is collected and passed to the controller. The specific interface between a hub and the controller is
highly implementation-dependent and, thus, not in the scope of this document. It is the duty of the hub communication interface to provide
the controller with all the device descriptors and channels in a transparent manner. It is common for a remote hub to feature a 
centralized IC (e.g.: An FPGA) integrating the device controllers and communication interface, but other schemes are possible.

Hubs are differentiated through a unique identifier, or hardware ID. This identifier represents a specific implementation of a hub, 
defined by a particular collection of devices on a specific hardware platform communicating with the controller through a specific link.
Changes in the device collection, the communications link or the general hardware architecture require a new identifier.


## Special devices {#special-devs}

There are two kinds of special devices that are mandatory in the specification: An information device on each hub and 
a heartbeat device in local hub 0.

### Information device

Every hub in an ONI system must feature a special device, located at address 0xFE, which supplies information about the hub. 
This device is not listed to the device map and, thus, has no device descriptor. The only interface it must provide is the
register interface, and it must not include any streams. The required register map is:

| Address | Register                         |
|---------|----------------------------------|
| 0x0000  | Hardware ID                      |
| 0x0001  | Hardware revision                |
| 0x0002  | Firmware version                 |
| 0x0003  | (OPTIONAL) Safe firmware version |
| 0x0004  | Hub clock frequency              |
| 0x0005  | Hub data latency                 |

Although all register reads are 32-bits in nature, not all registers make use of the complete width. The detailed meaning
of each register is:
- **Hardware ID**: A 32-bit value that uniquely identifies the hub. 
- **Hardware revision**: A 16-bit value identifying minor changes in the hardware that do not affect the overall operation of the hub and,
therefore, do not require a new ID. 
- **Firmware version**: A 16-bit value specifying firmware or gateware version of the main component driving the hub (e.g.: An FPGA or 
microcontroller)
- **Safe firmware version**: Optionally, for hubs that allow online updates of the firmware, 16-bit version of the fallback safe image, 
if any. 
- **Hub clock frequency**: 32-bit value holding the frequency, in Hz, of the hub clock that drives the *Hub_Timestamp* passed to the devices.
- **Hub data latency**: 32-bit value representing the average latency, in ns, of the physical link between the hub and the controller.
 Usually 0 in local hubs.

All 16-bit versions are in the format of Major(8bit).Minor(8bit). For example 0x0103 would imply version 1.3.
In the case of the information device located on hub 0, the versions refer to the physical controller hardware, where this hub 
is located.

### Heartbeat device

Local hub 0 must contain a heartbeat device. This is a simple device that periodically produces frames containing only the *Hub_Timestamp* 
and an empty payload, at a minimum rate of 10Hz. Its `ENABLE` register must be fixed and always active.

\newpage
# Controller and Host PC communication {#comm-protocol}
The controller purpose is to interface the system with the host computer. It aggregates and
routes device data and provides transparent access to all devices, independently of their 
physical location. The host also contains a common clock that is used to timestamp data 
from all devices, independently of their origin hub.

Communication between the controller and the host computer shall occur
over four communication channels:

1. Input: Read-only, high-bandwidth controller to host streaming containing device samples.
1. Output: Write-only, high-bandwidth host to controller streaming for sending data to the devices.
1. Signal: Read stream. For short-messages and asynchronous hardware events. 
1. Configuration: Bidirectional, register-based, 


Access to all these channels is blocking, i.e.: transactions to each of the channels will
block the channel until it is completed and no concurrent access to a single channel is permitted.
However, channels are independent and concurrent access to _different_ channels must be allowed.
A stream transaction is defined as a block read or write of a set number of bytes, while a register
transaction is defined to a single read or write access to an individual address.
   

Required characteristics of these channels are described in the following
sections.

## Data read channel {#data-rd-chan}

- __Word size__ : 32 bits
- __Channel type__ : Stream
- __Direction__ : Read

The _data read_ channel provides high bandwidth communication from the
controller to the host computer. Data from the read stream of all devices
that support is is aggregated and multiplexed by the controller and sent to the
host through this channel.

Data should be pushed to this channel as fast as possible and it is the responsibility of 
the host to read it at a quick enough pace. It is recommended that any ONI system implements
some kind of internal buffering to palliate the effects of uneven reading times caused 
by computer operating systems or other software limitations.

### Data Frames {#frame}

Data from the read channel is packed in frames, each frame corresponding to a single device sample.
The frame format is:

```
uint64  Common_Timestamp
uint32  Device_Address
uint32  Sample_Size
var     Sample
```

Where *Common_Timestamp* is a counter common to all devices generated by the controller
common acquisition clock. *Device_Address* is the address of the device producing the data,
as featured on the device map. *Sample_Size* is the full size of the sample, and must be
equal to the *Read_Sample_Size* field of the device descriptor. And *Sample* is the
complete data sample as described on the [device sample format](#dev-sample) section.


## Data write channel {#data-wr-chan}

- __Word size__ : 32 bits
- __Channel type__ : Stream
- __Direction__ : Write

The _data write_ channel provides high bandwidth communication from the host
computer to the controller, used to send data to the devices.

Data is sent with a [frame](#frame) format identical to the one used for read, but
without the *Common_Timestamp* field. It is the responsibility of the controller to
accept frames at any rate the computer might be sending them. Currently, there is no
defined mechanism to inform the host of any possible dropped frame on the write channel.

## Signal channel  {#sig-chan}

- __Word size__ : 8 bits
- __Channel type__ : Stream
- __Direction__ : Read

The _signal_ channel provides a way for the controller to inform the host of
configuration results, which may be provided with a significant delay.
Additionally, it is the channel over which the controller send the device 
map to the host following a system reset.
Signal data is framed into packets using Consistent
Overhead Byte Stuffing
([COBS](https://en.wikipedia.org/wiki/Consistent_Overhead_Byte_Stuffing)).
Within this scheme, packets are delimited using 0's and always have the
following format:

```
... | PACKET_FLAG data | ...
```

where `PACKET_FLAG` is 32-bit unsigned integer with a single unique bit
setting, ` | ` represents a packet delimiter, and `...` represents other
packets. This stream can be read and ignored  until a desired packet is
received. Reading this stream shall block if no data is available, which allows
asynchronous configuration acknowledgment. Valid `PACKET_FLAG`s are:

``` 
NULLSIG      = 0x00000001 // Null signal, ignored by host
CONFIGWACK   = 0x00000002 // Configuration write-acknowledgment
CONFIGWNACK  = 0x00000004 // Configuration no-write-acknowledgment
CONFIGRACK   = 0x00000008 // Configuration read-acknowledgment
CONFIGRNACK  = 0x00000010 // Configuration no-read-acknowledgment
DEVICEMAPACK = 0x00000020 // Device map start acknowledgment
DEVICEINST   = 0x00000040 // Device map instance
```

Following a hardware reset, the signal channel is used to provide the device
map to the host using the following packet sequence:

```
... | DEVICEMAPACK, uint32 num_devices | DEVICEINST uint32 dev_addr_0, device_descriptor dev_0
    | DEVICEINST uint32 dev_addr_1, device_descriptor dev_1 | ... | DEVICEINST uint32 dev_addr_n, device_descriptor dev_n| ...
```
Where dev_addr_n is the full address of each device as described on the [device map](#ONI-devmap) section and
dev_n the full device descriptor as described on the [devices](#devs)] section
numerical ID of each device and dev_n_port the physical port to which the hub containing this device is connected.


Following a device register read or write (see [configuration
channel](#conf-chan)), ACK or NACK signals are pushed onto the signal stream by
the controller. For instance, on a successful register read:

```
... | CONFIGRACK | ...
```

## Configuration channel {#conf-chan}

- __Word size__ : 32 bits
- __Channel type__ : Register
- __Direction__ : Read-Write

The _configuration_ channel supports addressed access to a set of
configuration registers.
There are two classes of registers handled by the configuration channel:
the first set of registers encapsulates a generic device register programming
interface. The remaining registers are for global context control and
configuration and provide access to acquisition parameters and state control.

The interface must use 32-bit values and, at least, 24-bit addressing. The
required register map is as follows:

| Address      | Name                      | Type               |
|--------------|---------------------------|--------------------|
| 0x00000000   | Device Address            | Register interface |
| 0x00000001   | Register Address          | Register interface |
| 0x00000002   | Register Value             | Register interface |
| 0x00000003   | Read/Write                | Register interface |
| 0x00000004   | Trigger                   | Register interface |
| 0x00000005   | Running                   | Global             |
| 0x00000006   | Reset                     | Global             |
| 0x00000007   | System Clock              | Global             |
| 0x00000008   | Acquisition Clock         | Global             |
| 0x00000009   | Reset acquisition counter | Global             |
| 0x0000000A   | Hardware address          | Global             |


### Device register programming interface
The device programming interface allows transparent access to the individual devices
register maps. It provides a general purpose abstraction that hides the specifics
of any particular implementation. It is composed of the following configuration
channel registers:

- `Device Address`: Specify the fully qualified address of a device as enumerated 
  in the device map (e.g. an Intan chip, or a IMU chip) and to which communication 
  will be directed as described below.

- `Register Address`: The register address of configuration to be
  written

- `Register Value`: configuration value to be written to or read
  from and that corresponds to the register `Register Address` of device 
  located at `Device Address` in the map.

- `Read/Write`: A flag indicating if a read or write should be
  performed.  0 indicates read operation. A value > 0 indicates write
  operation.

- `Trigger`: Set > 0 to trigger either register read or write
  operation depending on the state of `Read/Write`. If `Read/Write` is 0, a read
  is performed. In this case, after a succesful operation,
  `Register Value` is updated with value stored in the register at `Register Address` 
  on the device at `Device Address`. If `Read/Write` is 1,
  `Register Value` is written to register at `Register Address` on the device at 
  `Device Address`. The `Trigger` register is always be set low by the
  controller following transmission even if it is not successful or does not make
  sense given the address register values. 

Appropriate values of `Register Address` and `Register Value` are
determined by:

- Looking at a device's data sheet if the device is an integrated circuit and using raw registers
- Examining the ONI Device Datasheet for devices officially supported by this project.

When a host requests a device register _read_, the following following sequence
must be performed:

1. Check the value of `Trigger`.
    - If it is 0, the procedure can proceed.
    - Else, the hardware is busy with a previous transaction and a new one cannot be issued.
1. The target device is selected by writting its address, as featured on the device map, into 
`Device Address` on the controller
1. The desired register address within the device register map is written into `Register Address`
on the controller.
1. The `Read/Write` register on the controller is set to 0x00.
1. The `Trigger` register on the controller is set to 0x01,
triggering configuration transmission.
    1. (Controller) A register read is routed by the controller to the appropriate device.
    1. (Controller) `Trigger` is set to 0x00 once the operation finishes.
    1. (Controller) `CONFIGRACK` is pushed into the signal stream if the operation 
    was successful, `CONFIGRNACK` is pushed if it failed.
1. The signal stream must be pumped until either `CONFIGRACK` or `CONFIGRNACK` is
   received indicating that controller has either:
    - Completed reading the specified device register and copied its value to
      the `Register Value` register.
    - Failed to read the register in which case the value of `Register Value`
      contains invalid data.
1. If operation was successful, the `Register Value` can be read

When a host requests a device register _write_, the following following sequence
must be performed:

1. Check the value of `Trigger`.
    - If it is 0, the procedure can proceed.
    - Else, the hardware is busy with a previous transaction and a new one cannot be issued.
1. The target device is selected by writting its address, as featured on the device map, into 
`Device Address` on the controller
1. The desired register address within the device register map is written into `Register Address`
on the controller.
1. The `Read/Write` register on the controller is set to 0x01.
1. The `Trigger` register on the controller is set to 0x01,
triggering configuration transmission.
    1. (Controller) A register write is routed by the controller to the appropriate device.
    1. (Controller) `Trigger` is set to 0x00 once the operation finishes.
    1. (Controller) `CONFIGWACK` is pushed into the signal stream if the operation 
    was successful, `CONFIGWNACK` is pushed if it failed.
1. The signal stream must be pumped until either `CONFIGWACK` or `CONFIGWNACK` is
   received indicating that the controller has either:
    - Successfully completed writing the specified device register
    - Failed to write the register

Following successful or unsuccessful device register read or write, the
appropriate ACK or NACK packets _must_ be passed to the [signal
channel](#sig-chan) by the controller. If they are not, the register read and write calls will
block indefinitely.

### Global acquisition registers
The following global acquisition registers provide information about, and
control over, the entire acquisition system:

- `Running`: set to > 0 to run the system clock and produce data. Set
  to 0 to stop the system clock and therefore stop data flow. Results in no
  other configuration changes.

- `Reset`: set to > 0 to trigger a hardware reset and send a fresh
  device map to the host. Devices are reset but their manages registers might 
  remain unchanged, depending on their configuration (See the [Device registers](#dev-register)
  section for more information). Set to 0 by the controller upon entering the reset state.

- `System Clock`: A read-only register specifying the master hardware clock frequency in Hz. 
This is the clock used by the controller to perform data transmission.

- `Acquisition Clock`: A read-only register specifying the system common clock frequency in Hz. 
This clock is used to generate an acquisition counter that timestamps data from all the devices.
The *Common_Timestamp* in the read [frame](#frame) header is incremented at this frequency.
  
- `Reset acquisition counter`: This register is used to reset the counter generating the 
*Common_Timestamp* used in the device frames. A value if 1 will reset the counter to 0 without
affecting the `Running` state. A value of 2 will reset the counter and, at the same time, 
set `Running` to 1, starting data production.

- `Hardware Address`: This is used for systems that allow multiple controllers with a
link between them to synchronize their *Common_Timestamps*. When resetting the acquisition
counter through the `Reset acquisition counter` on a device with a `Hardware Address` of 0,
this command will be sent through an external link to all non-zero devices, synchronizing the counters.
Multiple controller support or hardware-based timestamp synchronization through dedicated links are
optional features of an ONI system.

